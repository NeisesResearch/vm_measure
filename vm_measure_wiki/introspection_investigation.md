## Making sense of unadulterated physical memory

What are we trying to do here?
> We want to hash the read-only data of each loaded kernel module.

What's the problem?
> Our input is simply this: a snapshot of the "physical" memory space of the system.

### Finding a Needle in a Haystack

Wow, okay. So what's the plan?
> Well, there's a list-head struct which could be used to find the modules in memory.

How can we find that struct in the memory snapshot?
> Fortunately, that struct does not change location from boot to boot, so if we find it once, we find it for good.

Great, but how can we find it even once?
> We can use a tool from the Volatility community, called Dwarf2Json.

What does that do?
> It takes as input a kernel (built with debugging symbols) and a System.map
> file, both of which are generated by kernel compilation. Then it outputs a
> table of symbols together with their virtual addresses.

Alright, so we can use that to find the virtual address of the struct... but our snapshot is physical memory, right?
> Yes, that's right. So we can write a kernel module for this system which
> takes our virtual address at compile time, and then returns the associated
> physical address at runtime.

Oh, that should be easy right?
> In theory, yes, but in reality we've come upon a curious roadblock. We've
> achieved some success, but at a certain point, the addresses we're finding
> are apparently nonsense.

That's interesting. First tell me about the success we've had. Then I want to hear the nonsense.
> Fine. We're able to locate that struct. We believe it to be the correct
> object because of the way we are able to interact with it. The object is, in
> total, 2 addresses placed next to each other. One address should point to the
> first loaded module, and the other should point to the last loaded module.
> The modules are part of a linked list structure.

So we should be able to use those addresses to traverse the list of modules!
> Right. So when one module is loaded, both those addresses point to a single
> place in memory. When we insmod a new module, one of those addresses changes
> to reflect that. When we rmmod that module, the addresses go back to the way
> they were. This can be repeated ad nauseum, and it is expected behavior based
> on the data structure at hand.

Wow, that's pretty cool. So what's the problem?
> Those two addresses point to apparently inaccessible places in memory. When
> we convert them to physical addresses using the virt-to-phys method, the
> result is a number less than the VM-RAM-BASE appointed in configuration
> files.

What does that mean?
> It could mean a few things. Perhaps our introspection dataport does not reach
> the entirety of the system memory. Maybe that address is a valid one, but
> it's simply out of reach for some reason. Or perhaps the virt-to-phys method
> is flawed. Maybe the physical address we're given was not computed correctly
> for some reason. Neither of these things seem to make much sense, but we
> can't think of anything else.

Okay, so what now?
> Now we reach out to Ihor.
