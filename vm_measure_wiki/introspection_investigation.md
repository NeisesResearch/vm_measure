## Making sense of unadulterated physical memory

What are we trying to do here?
> We want to hash the read-only data of each loaded kernel module.

What's the problem?
> Our input is simply this: a snapshot of the "physical" memory space of the system.

## Finding a Needle in a Haystack

Wow, okay. So what's the plan?
> Well, there's a list-head struct which could be used to find the modules in memory.

How can we find that struct in the memory snapshot?
> Fortunately, that struct does not change location from boot to boot, so if we find it once, we find it for good.

Great, but how can we find it even once?
> We can use a tool from the Volatility community, called Dwarf2Json.

What does that do?
> It takes as input a kernel (built with debugging symbols) and a System.map
> file, both of which are generated by kernel compilation. Then it outputs a
> table of symbols together with their virtual addresses.

What a high utility item!
> I agree, but it should be noted that this strategy will likely only work
> within a given linux kernel compilation. That is to say, even a change in the
> patch of the kernel could give different results. So 4.9.275 might yield
> different addresses than 4.9.292. So be careful.

## Thank you, Volatility community

Alright, so we can use that to find the virtual address of the struct... but our snapshot is physical memory, right?
> Yes, that's right. So we can write a kernel module for this system which
> takes our virtual address at compile time, and then returns the associated
> physical address at runtime.

Oh, that should be easy right?
> In theory, yes, but in reality we've come upon a curious roadblock. We've
> achieved some success, but at a certain point, the addresses we're finding
> are apparently nonsense.

That's interesting. First tell me about the success we've had. Then I want to hear the nonsense.
> Fine. We're able to locate that struct. We believe it to be the correct
> object because of the way we are able to interact with it. The object is, in
> total, 2 addresses placed next to each other. One address should point to the
> first loaded module, and the other should point to the last loaded module.
> The modules are part of a linked list structure.

So we should be able to use those addresses to traverse the list of modules!
> Right. So when one module is loaded, both those addresses point to a single
> place in memory. When we insmod a new module, one of those addresses changes
> to reflect that. When we rmmod that module, the addresses go back to the way
> they were. This can be repeated ad nauseum, and it is expected behavior based
> on the data structure at hand.

## Apparent nonsense

Wow, that's pretty cool. So what's the problem?
> Those two addresses point to apparently inaccessible places in memory. When
> we convert them to physical addresses using the virt-to-phys method, the
> result is a number less than the VM-RAM-BASE appointed in configuration
> files.

What does that mean?
> It could mean a few things. Perhaps our introspection dataport does not reach
> the entirety of the system memory. Maybe that address is a valid one, but
> it's simply out of reach for some reason. Or perhaps the virt-to-phys method
> is flawed. Maybe the physical address we're given was not computed correctly
> for some reason. Neither of these things seem to make much sense, but we
> can't think of anything else.

Okay, so what now?
> Now we reach out to Ihor.

## Trying to find sense
Alright, so is there anything we can do while we reach out for expert help?
> Yeah, we could just scan the memory snapshot for the other list-head structs.
> All we need to do is reconstruct the linked list in this way.

How can we do that?
> We've discovered that the linked list is appended to on an insmod call. So
> the list goes {Head, ModuleLoadedFirst, ModuleLoadedSecond,
> ModuleLoadedThird, ...}.

Okay, then we just need to know the address for each module. Is that possible?
> Yes, in a sense. When we insert modules for the first time, they are always
> in the same positions. So we can experiementally determine addresses in at
> least some situtations.

Does that not work for other situations?
> It might have to do with the module size. All tested modules so far have been
> of identical size. A large module might push the boundaries.

## Grabbing the Rodata
So we can get ourself into some finite number of modules. How do we get the rodata?
> We can reverse-engineer the module struct spec because we compiled the kernel
> ourselves. There are only 3 precompiler conditionals in our module.h, and
> they are as follows:
> * CONFIG-SYSFS = y
> * CONFIG-UNUSED-SYMBOLS is NOT SET
> * CONFIG-MODULE-SIG is NOT SET

So we can just count forward in the data till we get what we want, right?
> Yes and no. We'll be able to seek to the pointer which points to the modules
> code and data, but there's no promise we'll be able to actually follow that
> pointer.

Why not?
> The same trouble we had before: we don't know how to convert these virtual
> addresses to physical addresses, which we require in order to index them in
> our "memory snapshot."

## Rodata pointer problem
Is it what you thought?
> Yes, we've uncovered the offset to the module-layout struct, whose first
> entry is a pointer to the module's data. These pointers so uncovered agree
> with the data we can find via `cat /proc/modules`. Unfortunately however, yes, we don't
> know how to follow this pointer.

So now what?
> Now we're back to waiting and thinking. Maybe we should write.

## A potential solution
I hear you have good news?
> I think so. The problem is I don't know the exact form of the page tables in
> this version of Linux. But I've found two kernel symbols: page-mapping and
> page-mapped.

What are those symbols?
> They point to address-space structs as declared in include/linux/mm.h and
> defined in include/linux/fs.h. However, this information doesn't really seem
> to help. But I had an idea while I slept.

Did you seriously?
> Yes. If the page table is just a mapping of virtual addresses to physical
> addresses, I should be able to scan the memory snapshot for these addresses,
> right?

That makes pretty good sense. Are page tables actually like that?
> Unfortunately no. In fact, I'm having a hard time understanding paging in
> Linux.

## Some other idea
Now what?

